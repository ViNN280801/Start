# Проект "Старт-1"

## Цели и Задачи Проекта "Старт-1"

**Цель проекта:** Создать ПО для комплексного моделирования осаждения частиц в вакуумной камере с учетом сопутствующих физических процессов.

**Задачи:**

1.  **Физическое моделирование:** Реализовать движение частиц, расчет полей (МКЭ), генерацию частиц, столкновения, распыление мишени.
2.  **Численные методы:** Применить PIC-метод, использовать HPC-библиотеки (Trilinos, CUDA, OpenMP), эффективные геометрические алгоритмы и HDF5 для данных.
3.  **Интерфейс:** Разработать GUI (Python/PyQt5) для управления геометрией (Gmsh), параметрами, запуском и визуализацией (VTK, Matplotlib).
4.  **Инфраструктура:** Использовать CMake, модульную структуру, тестирование (gTest), документирование (Doxygen), Docker и PyInstaller для сборки и развертывания.

## Краткий экскурс

Цель – реализовать ПО, моделирующее осаждение частиц на внутренние поверхности вакуумной камеры, учитывая все происходящие внутри физические процессы (в соответствии с технологическим процессом напыления).
Для этой цели были выбраны языки: C++17 (17 минимальная, то есть проект может компилироваться на 17) и Python3.7 (использовался 3.7.17).
В части С++ происходят все вычисления. Компилируется в linux executive файл и он ожидает на вход единственный параметр –    имя конфигурационного файла (json), где указаны все необходимые параметры моделирования. После вычислений все необходимые для визуализации данные (осажденные частицы, траектория движения частиц) записываются в hdf5 файл (осажденные частицы), а траектории каждой частицы в каждый момент времени записываются в json (оказалось, что так места меньше занимает).
В части Python был реализован графический интерфейс с использованием PyQt5. С геометрией все обстоит намного сложнее – испоьзовалась связка `vtk` (visualization toolkit) + `gmsh` (geometry and mesh). Gmsh сам по себе не очень удобный, но хорош в построении сеток, но сам по себе он не предоставляет каких либо визуализационных функций – все только для сеток (потому что этот инструмент в прицнипе посвящен построению сеток, а не визуализации геометрических объектов). И сложность с геометрией заключается такая, что у gmsh свои параметры на создание/изменение геом объектов, у vtk свои, и тут очень трудно подобрать (надо проводить вычисления на листочке буквально, чтобы понять ориентацию в пространстве когда орудуешь сразу обоими фреймфорками) параметры так, чтобы сетка, построенная с gmsh соответсовала положению в пространстве объекту vtk. Да и в принципе это разные инструменты для разных целей, поэтому достаточно сложно их кооперировать, но чтобы человек мог видеть, чем он оперирует в окне граф редактора, то нужно как-то с этим иметь дело. Итог: UI = gmsh (сетка для физ вычислений) + vtk (построение геом объектов для пользователя). Были подогнаны почти все примитивные геом объекты, кроме цилиндра, то есть если создать цилиндр в gmsh отдельно, а потом с этими же параметрами создать цилиндр в программе для Старт-1, то будут видны различия в ориентации в пространстве.
Принцип работы: запускается UI с помощью python `ui/main.py` (в режиме dev, так сказать, а в пользовательском это будет linux executable, построенный с помощью PyInstaller (есть скрипт в репозитории, который собирает приложение в исполнительный файл)), далее, пользователь строит что-нибудь или загружает сетку (поддерживается .stp), выставляет все необходимые параметры моделирования, нажимает или кнопку `Next >`, либо сочетание клавиш `Ctrl+R` и python код вызывает ранее скомпилированный С++ исполнительный файл, и сам подставляет туда конфигурационный файл, производятся вычисления, затем, в графическом интерфейсе можно посмотреть результат – перекидывает на вкладку **Results**, и там будет показано осаждение на сетку.

## Часть 1. C++ модули

> Сразу скажу, **модули**, слово такое к С++ не особо относится конечно, но так понятнее для других, кто не программист и в принципе меня просили всегда писать и выражаться в данной компании именно таким словом. 

### DataHandling

Модуль DataHandling предназначен для управления потоками данных в процессе моделирования. Он обеспечивает загрузку, сохранение и обработку как входных данных для моделирования, так и результатов вычислений.

Ключевым компонентом данного модуля является класс `TriangleMeshHdf5Manager`, который обеспечивает двунаправленное взаимодействие между треугольными сетками и файлами формата HDF5. Этот формат был выбран из-за его производительности при работе с большими наборами научных данных и поддержки иерархической структуры хранения. Менеджер треугольных сеток получает геометрические данные из модуля `Geometry` и структурирует их для эффективного хранения в HDF5-файлах. При необходимости он может также выполнять обратную операцию, восстанавливая геометрические структуры из файла.

Другим важным компонентом является `SettledParticleHDF5Writer`, который специализируется на записи данных об осажденных частицах. Он оптимизирован для параллельной обработки больших объемов данных и включает механизмы сжатия для экономии дискового пространства. В процессе моделирования миллионы или больше частиц могут осаждаться на поверхности, и эффективное сохранение этих данных важно для последующего анализа и визуализации.

Модуль также включает набор специализированных исключений `DataHandlingExceptions` (каждый из логичечких компонентов, папок высокого уровня, например, `DataHandling`, `FiniteElementMethod`, `Generators`, и тд имеют свой 1 файл исключений, которые объявляются макросами при помощи `Utilities/ExceptionMacros.hpp`), которые обеспечивают диагностику ошибок, связанных с обработкой данных. Эти исключения организованы в иерархическую структуру, что позволяет более гибко обрабатывать различные ситуации.

Взаимодействие с HDF5 осуществляется напрямую через официальный [C++ API библиотеки](https://davis.lbl.gov/Manuals/HDF5-1.8.7/cpplus_RM/index.html). Для геометрических операций используется библиотека [CGAL](https://www.cgal.org/documentation.html), которая предоставляет надежную основу для манипуляций с трехмерными объектами.

### FiniteElementMethod

Модуль FiniteElementMethod реализует метод конечных элементов (МКЭ) для численного решения дифференциальных уравнений, описывающих электромагнитные поля в вакуумной камере. Один из самых сложных модулей как в плане понимания, так и в плане реализации.

Структура модуля разделена на логические компоненты:
- Сборщики (`Assemblers`) отвечают за формирование глобальной матрицы жесткости и вектора нагрузки из локальных матриц элементов. Ключевым компонентом здесь является `GSMAssembler`, который выполняет сборку матриц для уравнения Пуассона с использованием высокопроизводительных библиотек [Trilinos/Tpetra](https://docs.trilinos.org/dev/packages/tpetra/doc/html/) для распределенного хранения разреженных матриц (это такие, у которых много 0 и очень мало нормальных данных, ненулевых) и [Kokkos](https://trilinos.github.io/kokkos.html) для параллельных вычислений.
- `BoundaryConditions` управляет применением различных типов граничных условий к системе уравнений. Реализованы условия Дирихле (фиксированное значение). Классы `MatrixBoundaryConditionsManager` и `VectorBoundaryConditionsManager` модифицируют матрицу и вектор правой части соответственно для корректного учета этих условий.
- `Cell` определяет различные типы конечных элементов, преимущественно тетраэдры, поскольку они хорошо подходят для аппроксимации сложных трехмерных геометрий. Класс `CellSelector` предоставляет интерфейс для выбора нужного типа элемента в зависимости от требований задачи.
- `Cubature` реализует алгоритмы численного интегрирования для вычисления локальных матриц. Класс `CubatureManager` поддерживает различные степени точности интегрирования, от 1 до 20 точек кубатуры.
- `LinearAlgebraManagers` управляет матрицами и векторами, используемыми в МКЭ. Классы `MatrixManager` и `VectorManager` предоставляют высокоуровневый API к функциональности Tpetra, скрывая сложности работы с распределенными структурами данных.
- `Solvers` содержит реализации различных методов решения систем линейных уравнений. Класс `MatrixEquationSolver` предоставляет доступ к итерационным методам из библиотеки [Belos](https://trilinos.github.io/belos.html), включая CG (метод сопряженных градиентов), GMRES (обобщенный метод минимальных невязок) и BiCGStab (метод бисопряженных градиентов со стабилизацией). Также поддерживаются различные предобуславливатели (preconditioner) для ускорения сходимости.

> Все это очень сложные математические вещи, в которых я не очень разбираюсь, поэтому просто делал по подсказкам людей из форумов и по презентациям трилиноса + chatgpt. Далеко не факт, что то, что реализовано на 100% верно, это стоит обсуждать с тем, кто очень хорошо знаком с такой математикой.
 
- `FEMTypes.hpp` определяет основные типы данных, используемые в МКЭ, включая степени свободы, типы элементов, перечисления для методов решения и структуры для представления базисных функций.

Математика, которая стоит за кодом:

В основе модуля `FiniteElementMethod` лежит решение **уравнения Пуассона**, которое описывает электростатический потенциал \( u \) в области \(\Omega\) при наличии объемной плотности заряда \(\rho\):

\[
-\nabla \cdot (\epsilon \nabla u) = \rho \quad \text{в } \Omega
\]

Здесь \(\epsilon\) - это диэлектрическая проницаемость среды (в нашем случае, скорее всего, вакуума). Это уравнение в частных производных, и напрямую решать его для сложных геометрий бывает очень трудно.

Метод конечных элементов (МКЭ) позволяет найти **приближенное** решение этого уравнения. Идея в следующем:

1.  **Слабая формулировка:** Вместо того чтобы требовать выполнения уравнения в *каждой* точке области (что сложно), мы переходим к "слабой" или "интегральной" формулировке. Мы умножаем уравнение на некоторую "тестовую" функцию \( v \) и интегрируем по всей области \(\Omega\):
    \[
    -\int_{\Omega} v (\nabla \cdot (\epsilon \nabla u)) \, dV = \int_{\Omega} v \rho \, dV
    \]
    Далее, используя математические трюки (интегрирование по частям или формулу Грина), мы "перебрасываем" одну производную с искомой функции \( u \) на тестовую функцию \( v \). Это позволяет работать с функциями, которые не обязаны иметь вторые производные, что удобно для аппроксимации. После интегрирования по частям получаем:
    \[
    \int_{\Omega} \epsilon (\nabla v \cdot \nabla u) \, dV = \int_{\Omega} v \rho \, dV + \text{(граничные члены)}
    \]
    Граничные члены зависят от условий на границе области (например, заданный потенциал или поток). Эта форма называется **слабой постановкой** задачи. Нам нужно найти такую функцию \( u \), чтобы это равенство выполнялось для *любой* подходящей тестовой функции \( v \).

2.  **Дискретизация:** Всю нашу сложную геометрическую область \(\Omega\) мы разбиваем на простые элементы (в нашем случае - тетраэдры). Внутри каждого тетраэдра мы аппроксимируем (приближаем) искомую функцию \( u \) с помощью простых **базисных функций** \( N_j(x) \). Обычно эти функции связаны с узлами сетки (вершинами тетраэдров). Для тетраэдров часто используют **линейные базисные функции** (полиномы первого порядка). Это значит, что внутри каждого тетраэдра потенциал \( u \) меняется линейно. Наше приближенное решение \( u_h \) тогда выглядит как сумма:
    \[
    u_h(x) = \sum_{j=1}^{N} U_j N_j(x)
    \]
    Здесь \( N \) - общее число узлов сетки, а \( U_j \) - это **неизвестные значения потенциала** в узлах \( j \). Именно их мы и хотим найти.

3.  **Система уравнений:** Мы подставляем наше приближенное решение \( u_h \) в слабую формулировку. В качестве тестовых функций \( v \) мы тоже берем наши базисные функции \( N_i \). После подстановки и некоторых преобразований мы получаем систему линейных алгебраических уравнений (СЛАУ):
    \[
    K U = F
    \]
    Где:
    *   \( U \) - это вектор неизвестных узловых значений потенциала \( [U_1, U_2, ..., U_N]^T \).
    *   \( K \) - это **глобальная матрица жесткости**. Ее элементы \( K_{ij} \) вычисляются как интегралы от произведений градиентов базисных функций:
        \[
        K_{ij} = \int_{\Omega} \epsilon (\nabla N_i \cdot \nabla N_j) \, dV
        \]
        Эта матрица обычно **разреженная** (много нулей), потому что базисные функции \( N_i \) и \( N_j \) "живут" только на небольшом количестве элементов сетки, и их градиенты пересекаются (дают ненулевой интеграл) только для соседних узлов.
    *   \( F \) - это **вектор правой части** (или вектор нагрузки). Его элементы \( F_i \) вычисляются как интегралы от произведения базисной функции на плотность заряда \(\rho\):
        \[
        F_i = \int_{\Omega} N_i \rho \, dV + \text{(вклад от граничных условий)}
        \]

4.  **Сборка (Assembly):** Интегралы для \( K_{ij} \) и \( F_i \) вычисляются не по всей области \(\Omega\) сразу, а по каждому элементу (тетраэдру) \(\Omega_e\) отдельно. Сначала вычисляются **локальные матрицы жесткости** \( K^e \) и **локальные векторы нагрузки** \( F^e \) для каждого элемента. Затем эти локальные матрицы и векторы "собираются" в глобальную матрицу \( K \) и глобальный вектор \( F \). Этот процесс и реализован в `Assemblers`. Численное интегрирование по каждому элементу выполняется с помощью **кубатурных формул** (реализовано в `Cubature`).

5.  **Граничные условия:** Заданные значения потенциала на границах (условия Дирихле) учитываются путем модификации матрицы \( K \) и вектора \( F \). Этим занимается `BoundaryConditions`.

6.  **Решение СЛАУ:** Полученную систему \( K U = F \) нужно решить, чтобы найти вектор неизвестных \( U \). Поскольку матрица \( K \) большая и разреженная, для решения используются **итерационные методы**, такие как CG, GMRES, BiCGStab (реализованы в `Solvers` с помощью библиотеки Belos). Часто для ускорения сходимости этих методов применяют **предобуславливатели** (например, из библиотеки MueLu).

В итоге, МКЭ сводит сложную задачу решения уравнения в частных производных к задаче решения большой, но разреженной системы линейных алгебраических уравнений, которую можно эффективно решать численными методами. Точность решения зависит от густоты сетки и порядка используемых базисных функций (в нашем случае - линейных).

### Generators

Этот модуль занимается одной из ключевых задач моделирования – созданием частиц с нужными параметрами. Откуда берутся частицы, с какой скоростью летят, в каком направлении – все это определяется здесь. Чтобы было гибко и быстро, модуль разделен на две части: `Host` (для вычислений на обычном процессоре, CPU) и `Device` (для вычислений на графическом процессоре, GPU, с использованием [CUDA](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html)).

**Зачем два варианта?** Иногда нужно быстро сгенерировать огромное количество частиц (миллионы) – тут без GPU не обойтись, он делает это параллельно и очень быстро. А иногда нужно реализовать сложное распределение частиц или просто отладить код – для этого удобнее использовать CPU-версию.

В основе лежит абстрактный класс `ParticleGenerator`, который определяет общий интерфейс. Это значит, что остальной части программы неважно, как именно генерируются частицы – на CPU или GPU, – она просто вызывает одни и те же методы.

**Генерация на GPU (Device):**
Класс `ParticleGeneratorDevice` – это рабочая "лошадка" для массовой генерации. Он использует [CUDA](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html) для запуска тысяч потоков на GPU, каждый из которых может генерировать свою частицу или группу частиц. Это позволяет обрабатывать большие объемы данных (например, при моделировании распыления с поверхности).
Для генерации случайных чисел (например, для начальной скорости или положения) используется библиотека [cuRAND](https://docs.nvidia.com/cuda/curand/index.html), которая оптимизирована для GPU и предоставляет различные распределения: равномерное, нормальное (Гауссово), косинусное и Максвелловское. Класс `RealNumberGeneratorDevice` отвечает за работу с cuRAND.

**Генерация на CPU (Host):**
Класс `ParticleGeneratorHost` делает то же самое, но на CPU. Он медленнее, но может быть полезен для реализации более сложных или нестандартных моделей генерации, которые трудно или неэффективно переносить на GPU. Для случайных чисел он использует стандартную библиотеку C++ `<random>` ([std::random](https://en.cppreference.com/w/cpp/numeric/random)) и, возможно, [Boost.Random](https://www.boost.org/doc/libs/release/libs/random/doc/html/index.html) для специфических распределений. За это отвечает `RealNumberGeneratorHost`.

Такое разделение дает лучшее из обоих миров: скорость GPU для массовых задач и гибкость CPU для отладки и сложных случаев.

### Geometry

Этот модуль – фундамент всего моделирования. Он определяет, *где* все происходит. Здесь описаны геометрические формы, сетки, и инструменты для работы с ними. Без геометрии не получится ни двигать частицы, ни считать поля.

**Основные компоненты:**

-   **Basics:** Тут лежат самые основы – определения точек, векторов, треугольников и т.д. Для этого используется мощная библиотека [CGAL (Computational Geometry Algorithms Library)](https://www.cgal.org/), которая предоставляет надежные и точные геометрические структуры и алгоритмы. Файл `BaseTypes.hpp` определяет основные типы, а `GeometryVector.hpp` добавляет некоторые удобные операции.
-   **Mesh:** Сетки – это способ разбить сложную геометрию на простые кусочки (элементы), с которыми проще работать.
    -   **Surface (`SurfaceMesh.hpp`):** Это поверхностные сетки, состоящие из треугольников. Они описывают границы нашей вакуумной камеры, мишеней, подложек – всего, с чем частицы могут столкнуться. Хранят информацию о треугольниках и их нормалях.
    -   **Volumetric (`VolumetricMesh.hpp`):** Это объемные сетки, обычно состоящие из тетраэдров. Они заполняют весь объем камеры и используются в модуле МКЭ (`FiniteElementMethod`) для расчета полей.
    -   **Cubic (`CubicGrid.hpp`):** А вот это очень важная оптимизация. Представь, что у тебя миллион частиц и миллион тетраэдров в сетке. Чтобы узнать, в каком тетраэдре находится каждая частица, наивный подход потребует проверить каждую частицу на принадлежность каждому тетраэдру (или хотя бы многим из них). Это невероятно долго! `CubicGrid` решает эту проблему.
        *   **Как работает?**
            1.  Сначала определяется общий **ограничивающий параллелепипед (bounding box)** для всей объемной сетки ([CGAL Bbox_3](https://doc.cgal.org/latest/Kernel_23/classCGAL_1_1Bbox__3.html)).
            2.  Этот параллелепипед разбивается на **регулярную кубическую сетку** с заданным размером ячейки (например, 1 мм).
            3.  Для **каждого тетраэдра** объемной сетки определяется, с какими **кубическими ячейками** он пересекается ([CGAL do_overlap](https://doc.cgal.org/latest/Kernel_23/group__do__overlap__grp.html)). Эта информация сохраняется (`std::map<size_t, std::vector<GridIndex>>`, где ключ – ID тетраэдра, значение – список индексов ячеек).
        *   **В чем оптимизация?** Когда нам нужно найти тетраэдр для частицы с координатами (x, y, z):
            1.  Мы **мгновенно** вычисляем индекс кубической ячейки, в которую попадает эта точка (простое деление координат на размер ячейки).
            2.  Используя заранее построенную карту, мы получаем **небольшой список тетраэдров-кандидатов**, которые пересекаются с этой кубической ячейкой.
            3.  Проверяем принадлежность частицы **только этим нескольким тетраэдрам**, а не всем миллионам тетраэдров в исходной сетке.
        *   **Результат:** Поиск тетраэдра для частицы ускоряется в сотни или тысячи раз.

Если говорить о временной и пространственной сложности, то давайте сравним:

**Наивный алгоритм (перебор всех тетраэдров):**

*   **Time Complexity (Временная сложность):**
    *   *Подготовка:* \(O(1)\) – ничего заранее готовить не нужно.
    *   *Поиск для одной частицы:* Для каждой частицы нужно пройтись по всем \(N_t\) тетраэдрам и выполнить проверку принадлежности точки тетраэдру. Сама проверка (например, через барицентрические координаты) обычно занимает константное время, \(O(1)\). Итого, для одной частицы сложность \(O(N_t)\).
    *   *Поиск для \(N_p\) частиц:* \(O(N_p \times N_t)\).
*   **Space Complexity (Пространственная сложность):**
    *   *Дополнительная память:* \(O(1)\). Алгоритм не требует значительной дополнительной памяти, кроме хранения самой сетки и частиц.

**Алгоритм с `CubicGrid`:**

*   **Time Complexity (Временная сложность):**
    *   *Подготовка (построение сетки):* Нужно пройтись по всем \(N_t\) тетраэдрам и для каждого определить пересекаемые им кубические ячейки. Если \(k_{avg}\) – среднее число ячеек, с которыми пересекается один тетраэдр, то сложность подготовки примерно \(O(N_t \times k_{avg})\). Это делается один раз в начале.
    *   *Поиск для одной частицы:* 
        1.  Вычисление индекса кубической ячейки: \(O(1)\).
        2.  Получение списка тетраэдров-кандидатов для этой ячейки. В **идеальной реализации** (с использованием, например, `std::unordered_map<GridIndex, ...>`), это занимает в среднем \(O(1)\) или \(O(\log N_c)\) для `std::map`, где \(N_c\) - число ячеек. *В текущей реализации кода в `CubicGrid::getTetrahedronsByGridIndex` происходит перебор всех записей в `m_tetrahedronCells`, что дает \(O(N_t \times k_{avg})\), что неэффективно и сводит на нет пользу от сетки для этого этапа.*
        3.  Проверка принадлежности частицы тетраэдрам-кандидатам. Если в среднем в одной ячейке \(T_{cell, avg}\) тетраэдров, то этот этап занимает \(O(T_{cell, avg})\).
        Итого, **эффективная** реализация поиска для одной частицы имеет среднюю сложность \(O(1 + T_{cell, avg})\) или \(O(\log N_c + T_{cell, avg})\). Если сетка подобрана удачно, \(T_{cell, avg}\) будет гораздо меньше \(N_t\), и поиск будет близок к \(O(1)\).
    *   *Поиск для \(N_p\) частиц (эффективная реализация):* \(O(N_p \times (\log N_c + T_{cell, avg}))\)
*   **Space Complexity (Пространственная сложность):**
    *   *Дополнительная память:* Нужно хранить структуру `CubicGrid`, в основном карту `m_tetrahedronCells`. Ее размер пропорционален общему числу M пар (тетраэдр, пересекаемая им ячейка). Сложность \(O(M)\), где \(M \approx N_t \times k_{avg}\).

**Вывод:** `CubicGrid` требует затрат на предварительное построение (\(O(N_t \times k_{avg})\) ) и дополнительную память (\(O(N_t \times k_{avg})\) ), но **значительно** ускоряет поиск для каждой частицы (в среднем почти \(O(1)\), против \(O(N_t)\) у наивного алгоритма), если реализовать получение кандидатов эффективно. Это особенно выгодно, когда число частиц \(N_p\) очень велико, и поиск выполняется многократно.

Если говорить о временной и пространственной сложности, то...

-   **Utils:** Вспомогательные утилиты для проверки пересечений и прекрытий (в основном предназначен для треугольной сетки).

Все исключения, связанные с геометрией, определены в `GeometryExceptions.hpp`.

### Particle

Здесь определяется, что такое частица, какими свойствами она обладает, как она движется и взаимодействует.

-   **`Particle.hpp` / `Particle.cpp`:** Определяет основной класс `Particle`. Каждая частица – это объект этого класса, хранящий свою массу, заряд, текущие координаты (позицию), скорость, тип (например, ион аргона, атом титана, электрон) и другие нужные атрибуты. Класс также содержит методы для обновления состояния частицы, например, `updatePosition(double dt)`, который сдвигает частицу в соответствии с ее скоростью и шагом по времени `dt`.
-   **`ParticlePropertiesManager.hpp`:** Частицы бывают разные. Этот менеджер хранит "паспортные данные" для каждого типа частиц: точную массу, заряд, радиус (для моделей столкновений) и т.д. Когда нужно создать новую частицу определенного типа, менеджер предоставляет все необходимые физические константы.
-   **`ParticleDisplacer.hpp` / `ParticleDisplacer.cpp`:** Отвечает за самый важный процесс – перемещение частицы. Он берет текущую скорость частицы, силы, действующие на нее (например, от электрического поля), и шаг по времени `dt`, а затем вычисляет новую позицию и новую скорость. Для этого используются численные методы интегрирования уравнений движения. Простейший – метод Эйлера, но для большей точности могут применяться методы Верле или Рунге-Кутты (хотя они и более вычислительно дорогие).
-   **PhysicsCore:** Здесь живет физика взаимодействия частиц.
    -   **CollisionModel (`HSModel.hpp`, `VHSModel.hpp`, `VSSModel.hpp`):** Модели столкновений частиц друг с другом (например, иона с атомом газа). Реализованы разные модели при помощи [фабрики](https://refactoring.guru/design-patterns/catalog):
        -   HS (Hard Sphere): Простейшая модель упругих шаров.
        -   VHS (Variable Hard Sphere): Учитывает зависимость размера "шара" (сечения столкновения) от относительной скорости частиц.
        -   VSS (Variable Soft Sphere): Более сложная модель, учитывающая неупругие эффекты и вязкость.

> По сути все эти модели совсем немного отличаются друг от друга (математикой).

    -   **`ParticleDynamicUtils.hpp`:** Вспомогательные функции для расчета энергии, импульса и т.п.
-   **CUDA (`ParticleDevice.cuh`, `ParticleDevice.cu`, `ParticleDeviceMemoryConverter.cu`):** Так как частиц может быть очень много, их обработка (перемещение, проверка столкновений) хорошо параллелится. Эта часть модуля содержит GPU-версии структур данных для частиц (`ParticleDevice`) и функции для их обработки на GPU с использованием [CUDA](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html). `ParticleDeviceMemoryConverter` помогает эффективно копировать данные о частицах между памятью CPU (host) и памятью GPU (device) ([CUDA Memory Management](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#memory-management)).

Модуль активно использует возможности C++17/20 для написания чистого и эффективного кода. Исключения, специфичные для частиц, определены в `ParticleExceptions.hpp`.

### ParticleInCellEngine

Это основной вычислительный движок, реализующий метод **"частицы в ячейках" (Particle-In-Cell, PIC)** ([один из источников](https://picongpu.readthedocs.io/en/latest/models/pic.html)). Этот метод – стандарт для моделирования плазмы, где нужно учитывать и движение отдельных частиц, и создаваемые ими коллективные поля (например, электрическое поле).

**Идея PIC-метода:**

1.  **Движение частиц:** Частицы движутся под действием полей (например, электрического). Их траектории рассчитываются индивидуально (за это отвечает модуль `Particle`).
2.  **Поля на сетке:** Поля (например, электрический потенциал) рассчитываются не в каждой точке пространства, а только в узлах некоторой сетки (обычно той же, что используется в МКЭ, или специальной PIC-сетки).
3.  **Связь частиц и сетки:**
    *   **Сбор плотности (Gather):** Чтобы рассчитать поля, нужно знать, где находятся заряды. Заряд каждой частицы "размазывается" по ближайшим узлам сетки. Это делает `NodeChargeDensityProcessor`.
    *   **Решение для поля:** Зная плотность заряда в узлах сетки, можно решить уравнение для поля (например, уравнение Пуассона) на этой сетке. Этим занимается `ChargeDensityEquationSolver`, который взаимодействует с модулем `FiniteElementMethod` (используя решатели Trilinos/Belos).
    *   **Интерполяция поля (Scatter):** Чтобы узнать силу, действующую на частицу, значение поля интерполируется с узлов сетки в точку, где находится частица.
4.  **Повторение:** Цикл "движение частиц -> сбор плотности -> решение для поля -> интерполяция поля -> ..." повторяется на каждом шаге по времени.

**Основные компоненты модуля:**

-   **`ChargeDensityEquationSolver.cpp`:** Использует МКЭ (модуль `FiniteElementMethod`) для решения уравнения Пуассона на объемной сетке, находя распределение электрического потенциала.
-   **`NodeChargeDensityProcessor.cpp`:** Реализует этап "сбора плотности". Пробегает по всем частицам и распределяет их заряд по узлам сетки.
-   **`PICTypes.hpp`:** Определяет типы данных, специфичные для PIC-метода.
-   **ParticleDynamicsProcessor:** Нужен для динамики частиц. Он управляет:
    -   **`ParticleMovementTracker.cpp`:** Отслеживает, где находятся частицы, используя `CubicGrid` из `Geometry` для быстрого поиска тетраэдров, и вызывает `ParticleDisplacer` для их перемещения.
    -   **`ParticlePhysicsUpdater.cpp`:** Обновляет состояние частиц, учитывая силы от полей (интерполированных с сетки) и результаты столкновений (из `Particle/PhysicsCore`).
    -   **`ParticleSettler.cpp`:** Определяет, когда частица "осела" на поверхность, и удаляет ее из моделирования, записывая информацию о ней (через `DataHandling`).
    -   **`ParticleSurfaceCollisionHandler.cpp`:** Обрабатывает столкновения частиц с границами (поверхностями), используя модели отражения/поглощения.
    -   **`StopModelingObserver.cpp`:** Проверяет условия завершения моделирования (достигнуто время, количество частиц и т.д.).

Этот модуль интенсивно использует параллелизм:
-   Многие циклы по частицам распараллелены с помощью [OpenMP](https://www.openmp.org/) для CPU.
-   Ключевые, наиболее затратные операции (движение частиц, сбор плотности) могут быть перенесены на GPU с использованием [CUDA](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html).

Исключения определены в `PICExceptions.hpp`.

### SessionManagement

Этот модуль отвечает за удобство работы с программой и внешними инструментами.

-   **`GmshSessionManager.hpp`:** Просто использует RAII для управления ресурсами.
-   **`SessionManagementExceptions.hpp`:** Определяет ошибки, связанные с управлением сессиями, например, проблемы при запуске Gmsh или ошибки при чтении/записи файлов состояния.

### SputteringModel

**Важное замечание:** Код в этой директории (`SputteringModel.cpp`, `TwoPlatesCreator.cpp`) **не является частью основного интегрированного ПО "Старт-1"**, которое запускается через Python UI. Это **отдельная, небольшая программа/тестовый стенд**, которая компилируется в свой собственный исполняемый файл. Она была написана **для проверки и отладки физических моделей распыления** и, для генерации каких-то эталонных данных или калибровочных кривых.

-   **`SputteringModel.cpp/.hpp`:** Реализует саму физическую модель распыления.
-   **`TwoPlatesCreator.cpp/.hpp`:** Создает простую геометрию (две параллельные пластины – типичная конфигурация для экспериментов по распылению) для этого тестового стенда, чтобы было на чем проверять модель распыления.

Этот код полезен для верификации физики, но не участвует напрямую в основном цикле моделирования осаждения в сложной геометрии, который выполняется ядром `ParticleInCellEngine`.

### Utilities

Это набор вспомогательных инструментов, которые используются повсеместно в проекте. Цель – избежать дублирования кода и вынести общие задачи в отдельные, переиспользуемые компоненты.

-   **`Constants.hpp`:** Хранилище физических и математических констант (число пи, заряд электрона, масса протона и т.д.). Чтобы везде были одинаковые значения.
-   **`ConfigParser.hpp/.cpp`:** Парсер конфигурационных JSON-файлов. Использует библиотеку [nlohmann/json](https://github.com/nlohmann/json) для чтения параметров моделирования из файла, который передается C++ исполняемому файлу при запуске.
-   **`LogMacros.hpp`:** Макросы для вывода логов (информационных сообщений, предупреждений, ошибок, отладочной информации). Позволяют легко включать/выключать и перенаправлять вывод.
-   **`PreprocessorUtils.hpp`:** Макросы препроцессора (`#ifdef`, `#define`) для условной компиляции. Например, чтобы включать/выключать код для CUDA (`USE_CUDA`), OpenMP (`USE_OPENMP`).
-   **`Timer.hpp/.cpp`:** Класс для точного измерения времени выполнения участков кода. Полезно для поиска узких мест и оптимизации производительности. Конечно в самом ПО он не задействован, но может быть полезен при отладке. Имеет достаточно простой интерфейс использования. Неоднократно сам его использовал для отладки.
-   **`ThreadedProcessor.hpp`:** Обертка для упрощения параллельного выполнения задач на CPU с использованием стандартных предоставляемых С++ инструментов (`std::async`, `std::future`).
-   **`Utilities.hpp/.cpp`:** Набор разных мелких полезных функций: работа со строками, файловой системой, преобразования типов и т.п.
-   **CUDA (`DeviceUtils.cuh`, `CUDAWarningSuppress.hpp`):** Утилиты для работы с [CUDA](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html): проверка ошибок, управление устройствами, копирование памяти, подавление специфичных предупреждений компилятора `nvcc`.
-   **GmshUtilities (`GmshMesher.hpp`, `GmshUtils.hpp`):** Функции для упрощения взаимодействия с [Gmsh](https://gmsh.info/) (возможно, обертки над `GmshSessionManager`).
-   **`ExceptionMacros.hpp`:** Макросы для удобного создания и выбрасывания исключений стандартным образом по всему проекту.
-   **`Types.hpp`:** Определения общих типов данных (using-алиасы, typedef'ы), чтобы везде использовать одинаковые имена для сложных типов.
-   **`UtilitiesExceptions.hpp`:** Определения базовых исключений для утилит.
-   **`VersionCheck.hpp`:** Нужен для того, чтобы предостеречь от компиляции на несовместимой версии С++. Поддерживается несколько стандартов C++ (17, 20, 23, 26, ...).

Весь проект собирается с помощью системы сборки [CMake](https://cmake.org/) (`CMakeLists.txt` файлы в каждой директории), которая генерирует файлы для сборки под конкретный компилятор, например, [GCC (GNU Compiler Collection)](https://gcc.gnu.org/), и управляет зависимостями и опциями компиляции (включение CUDA, OpenMP, выбор стандарта C++). Если используется распределенная обработка на нескольких узлах, то также могут быть задействованы библиотеки стандарта [MPI (Message Passing Interface)](https://www.mpi-forum.org/docs/), такие как [OpenMPI](https://www.open-mpi.org/) или [MPICH](https://www.mpich.org/).

## Заключение для С++ части

C++ часть проекта "Старт-1" представляет собой сложную, но хорошо структурированную систему модулей, которые взаимодействуют для моделирования осаждения частиц на внутренние поверхности вакуумной камеры. Она активно использует возможности C++17 и C++20, а также ряд высокопроизводительных библиотек, таких как CUDA, OpenMP, HDF5, CGAL, Trilinos (тут внутри тоже используются OpenMP, MPI и CUDA, но для этого нужно скомпилировать Trilinos с соответствующими опциями, для этого посмотри в этот [источник](https://docs.trilinos.org/files/TrilinosBuildReference.pdf) или можешь с помощью [cmake-gui](https://cmake.org/cmake/help/latest/manual/cmake-gui.1.html) сконфигурировать проект Trilinos, затем посмотреть какие там флаги есть, а их там очень много).

> P.S. Кстати, в репозитории есть полезные файлы, которые помогут скомпилировать Trilinos (`Compiling_Trilinos.txt`), CGAL (`Compiling_CGAL.txt`) и решить проблему с PyQt5 (`fix_qt.txt`), если такая возникнет.

## Часть 2. Python UI

Пользовательский интерфейс (UI) проекта "Старт-1" написан на Python 3.7 и предназначен для работы в среде Linux. Он предоставляет графическую оболочку для настройки параметров моделирования, запуска C++ вычислительного ядра, управления геометрией и визуализации результатов.

> Честно говоря, тут черт ногу сломит, код плох, но он работает. Тут я сильно не буду расписывать, потому что по хорошему это все надо переписывать, и я напишу лишь общие слова по всем директориям.

**Основные используемые библиотеки и их назначение:**

*   **[PyQt5](https://www.riverbankcomputing.com/static/Docs/PyQt5/)**: Основной фреймворк для построения графического интерфейса. Отвечает за создание окон, кнопок, полей ввода, вкладок и обработку всех взаимодействий с пользователем (нажатия кнопок, ввод текста и т.д.).
*   **[VTK (Visualization Toolkit)](https://vtk.org/)**: Используется для 3D-визуализации геометрических моделей и результатов моделирования (например, отображения осажденных частиц на сетке) в окне приложения.
*   **[Gmsh](https://gmsh.info/)**: Интегрирован для создания и управления геометрическими моделями и генерации сеток непосредственно из интерфейса. Python API Gmsh позволяет вызывать его функции.
*   **[Matplotlib](https://matplotlib.org/)**: Применяется для построения 2D-графиков, например, для отображения гистограмм или других данных, полученных в результате анализа моделирования.
*   **[h5py](https://docs.h5py.org/en/stable/)**: Используется для чтения HDF5-файлов, в которые C++ ядро записывает результаты (например, данные об осажденных частицах) для их последующей визуализации в UI.
*   **[json](https://docs.python.org/3/library/json.html)**: Стандартная библиотека Python для работы с JSON-файлами, которые используются для сохранения и загрузки конфигураций моделирования.
*   **[psutil](https://psutil.readthedocs.io/en/latest/)**: Применяется для получения информации о системе и управления процессами, в частности, для запуска и мониторинга C++ вычислительного ядра как отдельного процесса.

**Структура директории `ui`:**

*   **`main.py`**: Точка входа для запуска Python UI. Инициализирует приложение PyQt5 и главное окно.
*   **`window.py`**: Содержит класс основного окна приложения (`QMainWindow`). Здесь определяется общая структура интерфейса, меню, панели инструментов и размещение основных виджетов, включая систему вкладок.
*   **`tabs/`**: Содержит классы для каждой отдельной вкладки интерфейса (например, вкладка для настройки геометрии, вкладка для параметров моделирования, вкладка для просмотра результатов). Каждая вкладка инкапсулирует свою логику и набор виджетов.
    *   `graphical_editor/`: Вкладка с графическим редактором, где происходит взаимодействие с VTK и Gmsh для построения и отображения геометрии.
    *   `results_tab.py`: Вкладка для отображения результатов, использующая Matplotlib и VTK для визуализации данных из h5py.
    *   `config_tab.py`: Вкладка для настройки параметров моделирования.
*   **`util/`**: Вспомогательные утилиты, используемые в разных частях UI. Например, функции для взаимодействия с файловой системой, преобразования данных или общие диалоговые окна.
*   **`field_validators/`**: Содержит классы валидаторов (наследники `QValidator` из PyQt5) для полей ввода. Они гарантируют, что пользователь вводит данные в корректном формате (например, только числа в определенном диапазоне).
*   **`logger/`**: Настройка и управление логированием событий в UI. Помогает отслеживать действия пользователя и возможные ошибки.
*   **`styles/`**: Файлы стилей для кастомизации внешнего вида интерфейса.
*   **`dialogs/`**: Классы для стандартных диалоговых окон (например, выбор файла, сообщения об ошибках, подтверждения).
*   **`constants/`**: Определения констант, используемых в UI (например, пути к ресурсам, стандартные значения).
*   **`data/`**: Возможно, используется для хранения каких-то статических данных или ресурсов, необходимых для UI.
*   **`tests/`**: Модульные тесты для компонентов Python UI (если они есть). `run_tests.py` - скрипт для их запуска.

**Взаимодействие с C++ ядром:**

UI не выполняет основные вычисления. Когда пользователь нажимает кнопку запуска моделирования, Python-код:
1.  Собирает все настроенные параметры из полей ввода.
2.  Сохраняет их в конфигурационный JSON-файл.
3.  Запускает скомпилированный C++ исполняемый файл (`nia_start_core`) как отдельный процесс (используя `QProcess`), передавая ему путь к JSON-файлу в качестве аргумента.
4.  Ожидает завершения C++ процесса.
5.  После завершения считывает результаты из HDF5-файлов (с помощью `h5py`) и отображает их на вкладке результатов.

Таким образом, Python UI служит удобной оболочкой для сложного C++ вычислительного ядра, делая процесс настройки, запуска и анализа моделирования более доступным для пользователя. А также, когда мы в отдельном процессе запускаем код моделирования, то окно приложения не зависает, в нем можно продолжать работать.

## Заключение для Python части (UI)

Python UI, построенный на PyQt5, VTK и Gmsh, предоставляет графическую оболочку для C++ ядра. Он позволяет пользователям создавать/импортировать геометрию, настраивать параметры, запускать вычисления и визуализировать результаты. Несмотря на функциональность, качество кода отмечено как неоптимальное, и сложности интеграции VTK/Gmsh требуют внимания. Переработка UI может улучшить его сопровождаемость.

## Дополнительные файлы

- `Doxyfile` - Конфигурационный файл для [Doxygen](https://www.doxygen.nl/), инструмента автоматической генерации документации из комментариев в исходном коде C++. Позволяет создавать HTML, LaTeX и другие форматы документации по структуре проекта.
- `kde_hist_plotter.py` - Скрипт на Python для визуализации результатов моделирования. Использует библиотеки `numpy`, `matplotlib` и `scipy` для построения гистограмм распределения толщины осажденного слоя и карт плотности осаждения методом ядерной оценки плотности (Kernel Density Estimation, KDE). Считывает данные из файлов `results/histogram.dat` и `results/kde.dat`.
- Директория `intermediateResults` - Содержит код и результаты промежуточных вычислений или тестов, выполненных физиком проекта. Использовался [Root CERN](https://root.cern/) для анализа и проверки физической части моделирования.
- `create_executable.sh` - Сборочный скрипт для создания дистрибутива приложения под Linux. Сначала он компилирует C++ ядро с помощью `compile.sh`, а затем использует [PyInstaller](https://pyinstaller.org/en/stable/) для упаковки Python UI (`ui/main.py`), скомпилированного C++ ядра и всех необходимых ресурсов (иконок, данных, UI-файлов) в единый исполняемый пакет.
- `requirements.txt` - Стандартный файл для менеджера пакетов `pip`, перечисляющий все Python-библиотеки, необходимые для запуска пользовательского интерфейса (UI).
- `run_in_docker.sh` - Скрипт для запуска приложения в [Docker](https://www.docker.com/) контейнере. Он собирает образ на основе `Dockerfile.ubuntu.executable`, настраивает перенаправление графического вывода (X11 forwarding) для отображения UI из контейнера и запускает приложение в изолированной среде.
- `show_git_changes.sh` - Вспомогательный скрипт для визуализации истории изменений в репозитории Git. Использует утилиту [gource](https://gource.io/), которая создает анимированное дерево коммитов и файлов.
- `update_base_images.sh` - Скрипт для сборки, тегирования и отправки базовых Docker-образов (для Fedora и Ubuntu) в репозиторий Docker Hub. Эти образы содержат предустановленные зависимости и используются для ускорения сборки основного Docker-образа приложения.
- `compile.sh` - Основной скрипт для компиляции C++ части проекта. Использует [CMake](https://cmake.org/) для конфигурации и сборки. Предоставляет различные опции: полная пересборка (`-r`), указание числа потоков компиляции (`-j`), выбор типа сборки (Debug/Release), компиляция и запуск тестов (`--tests`), компиляция отдельного теста модели распыления (`-sputtering`).
- `tests` - Директория, содержащая модульные и интеграционные тесты для C++ компонентов. Структура директории зеркально отражает `src`/`include`. Использует Google Test и CMake для сборки и запуска тестов (`compile.sh --tests`).

## Проблемы

В ходе разработки и анализа проекта был выявлен ряд проблем и потенциальных узких мест, требующих внимания и возможной доработки:

### 1. Расхождения в представлении геометрии

Как упоминалось в разделе "Краткий экскурс", существует сложность в согласовании геометрических представлений между библиотеками [VTK](https://vtk.org/) (используемой для визуализации в UI) и [Gmsh](https://gmsh.info/) (используемой для генерации сеток для C++ ядра). Параметры создания и трансформации объектов в этих библиотеках различаются, что приводит к трудностям при попытке точно совместить визуальное представление объекта в VTK с сеткой, генерируемой Gmsh. Это особенно заметно для цилиндра (в данной реализации), где ориентация в пространстве может не совпадать даже при использовании формально одинаковых параметров. Это требует ручных вычислений и подгонки для достижения соответствия, что усложняет работу с графическим редактором и может приводить к ошибкам в постановке задачи для моделирования.

### 2. Выбор шага по времени (`dt`) для моделирования

Текущий подход, позволяющий пользователю задавать фиксированный шаг по времени (`dt`), может приводить к нефизичным результатам, если выбранное значение `dt` слишком велико по сравнению с характерными временами процессов в системе.

*   **Пример:** Рассмотрим частицу титана (Ti) с типичной энергией после распыления \( E = 7 \, \text{эВ} \). Ее масса \( m \approx 7.498 \times 10^{-26} \, \text{кг} \). Скорость такой частицы можно оценить из формулы кинетической энергии \( E = \frac{mv^2}{2} \):    \[
    v = \sqrt{\frac{2E}{m}} = \sqrt{\frac{2 \times (7 \times 1.602 \times 10^{-19} \, \text{Дж})}{7.498 \times 10^{-26} \, \text{кг}}} \approx 5312 \, \text{м/с}
    \]
    Если пользователь установит шаг по времени, например, \( dt = 1 \times 10^{-6} \, \text{с} \) (1 микросекунда), то за один шаг частица пройдет расстояние:   \[
    S = v \times dt \approx 5312 \, \text{м/с} \times 10^{-6} \, \text{с} \approx 5.3 \, \text{мм}
    \]
    Это расстояние уже сопоставимо с размерами элементов сетки или даже характерными размерами камеры. Если же пользователь задаст значительно больший `dt` (как в исходном примере с 600 с, который является экстремальным), частица может "пролететь" всю камеру за один шаг, что полностью искажает физическую картину траектории и взаимодействий.

*   **Проблема с фиксированным `dt`:** Для корректного моделирования шаг `dt` должен быть достаточно мал, чтобы разрешать самые быстрые процессы (движение самых быстрых частиц на расстояние меньше размера ячейки сетки, время между столкновениями и т.д.). Однако, установка слишком малого `dt` неоправданно увеличивает вычислительные затраты.

*   **Идеи по улучшению:**
    *   **Адаптивный шаг по времени:** Идея заключается в том, чтобы изменять `dt` в ходе моделирования: уменьшать его, когда происходят быстрые процессы (например, частицы летят быстро или близко к поверхности), и увеличивать, когда система относительно стабильна. Однако, в контексте PIC-метода с непрерывной генерацией частиц (как при распылении) это создает сложности:
        -   Разные группы частиц (например, только что распыленные и уже замедлившиеся) имеют разные характерные времена движения.
        -   Выбор единого адаптивного `dt` для всех частиц становится проблемой: шаг, подходящий для медленных частиц, будет слишком велик для быстрых (искажение траекторий), а шаг, подходящий для быстрых, будет излишне мал для медленных (рост вычислительной нагрузки).
    *   **Индивидуальный `dt` для каждой частицы:** Теоретически, можно было бы продвигать каждую частицу со своим собственным шагом по времени. Однако, это крайне сложно реализовать в рамках синхронного PIC-цикла, требует сложной логики управления временем и синхронизации, и 100% приведет к потере производительности, потому что обрабатывать частицы в разных шагах по времени будет крайне затратно.

*   **Текущее состояние:** Вопрос выбора оптимального и физически обоснованного `dt` (возможно, с автоматической оценкой на основе параметров системы или ограничением максимального значения, доступного пользователю) остается открытым.

### 3. Потенциальные неточности в реализации МКЭ

Существуют опасения относительно точности реализации метода конечных элементов (МКЭ) для расчета электрического поля.

*   **Проблема:** В текущей реализации используются **линейные базисные функции** (полином первого порядка) на тетраэдральных элементах. Теоретически, использование линейных базисных функций для аппроксимации решения уравнения Пуассона должно приводить к тому, что **градиент** потенциала (то есть, электрическое поле) является **постоянной величиной** внутри каждого отдельного тетраэдра. Однако, наблюдаемые результаты расчета электрической напряженности могут не соответствовать этому ожиданию (поле может выглядеть не кусочно-постоянным).

*   **Возможные причины:**
    *   **Математическая постановка:** Неточности могут быть связаны с неправильным применением граничных условий, ошибками в выводе или реализации слабой формулировки уравнения, либо использованием неподходящих формул для расчета производных или интегралов.   *   **Реализация:** Возможны ошибки в коде сборки локальных/глобальных матриц (`Assemblers`), применении граничных условий (`BoundaryConditions`), вычислении интегралов (`Cubature`) или в самом процессе решения СЛАУ (`Solvers`). Также ошибки могут быть связаны с тем, как именно рассчитывается и визуализируется электрическое поле *из* полученного МКЭ решения для потенциала (например, при осреднении в узлах).\n

Для точной диагностики этой проблемы требуется тщательный анализ как математической постановки, так и конкретной реализации кода МКЭ экспертом в данной области.
